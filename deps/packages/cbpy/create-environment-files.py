#!/usr/bin/env python3

# This script is responsible for reading the files in ./platforms and writing
# the relevant info to the various ../environment-${platform}.txt files
#
# If it encounters issues in ../couchbase-server-black-duck-manifest.yaml it
# will error out with information about what changes are required.

import os
import re
import sys
import yaml
from shutil import copy
from string import Template
from collections import defaultdict

platforms = ["linux-x86_64", "linux-aarch64", "osx", "win"]
blackduck_manifest = yaml.safe_load(open("couchbase-server-black-duck-manifest.yaml"))
bd_ignored = [x.strip() for x in open("blackduck-ignore.txt").readlines() if not x.startswith("#") and x != ""]

def dd():
    return defaultdict(dd)

def comment(s):
    return f"#{' ' if len(s.strip()) > 0 else ''}{s}"

def raw_version_string(v):
    """
    returns a given string minus the leading v/V, to ease comparison
    """
    if str(v).lower()[0] == "v":
        return str(v[1:])
    return str(v)

def get_version_dict(f):
    """
    Retrieve a dict of product:versions from a requirements.txt
    style text file
    """
    d = {}
    for line in open(f).readlines():
        line = line.strip()
        if not line.startswith("#") and line != "":
            [dep, ver] = line.split("=")
            d[dep] = ver
    return d

def get_deps():
    """ Reads all platform files """
    deps = {}
    for platform in platforms:
        deps[platform] = {}
        lines = [f.strip() for f in open(f"package-lists/{platform}").readlines() if not f.startswith("#") and f != ""]
        for line in lines:
            [package, version] = re.split(r'\s+', line)[0:2]
            deps[platform][package] = version
    return deps

def update_cb_versions(cb_dependencies, cb_stubs, deps):
    """
    cb-dependencies/stubs versions can drift on update
    We need to ensure we're capturing the updated version information
    """
    for platform in platforms:
        for dep in deps[platform]:
            if dep in cb_dependencies and cb_dependencies[dep] != deps[platform][dep]:
                cb_dependencies[dep] = deps[platform][dep]
            if dep in cb_stubs and cb_stubs[dep] != deps[platform][dep]:
                cb_stubs[dep] = deps[platform][dep]

def inject_template(f, template, lines_before=1, lines_after=1):
    """ Formats and injects a template into f """
    template_lines = list(map(comment, open(f"templates/{template}").readlines()))
    outlines = (
        ["\n"] * lines_before +
        template_lines +
        ["\n"] * lines_after)
    f.writelines(outlines)

def write_environment_files(deps):
    """ Write the various environment files """
    # Write environment-base
    for platform in platforms:
        with open(f"environment-{platform}.txt", "w") as f:
            inject_template(f, "autogenerated-warning", lines_before=0, lines_after=0)
            inject_template(f, "explicit", lines_before=0)
            for dep in cb_dependencies:
                f.write(f"{dep}={cb_dependencies[dep]}\n")
            inject_template(f, "stubs")
            for dep in cb_stubs:
                f.write(f"{dep}={cb_stubs[dep]}\n")
            inject_template(f, "transitive")
            for dep in deps[platform]:
                if dep not in cb_dependencies and dep not in cb_stubs:
                    f.write(f"{dep}={deps[platform][dep]}\n")
    print("Environment files saved in ../")

def detect_blackduck_drift():
    blackduck = dd()
    # Figure out what packages have drifted or are missing from black duck manifest
    for target_platform in deps:
        for dep in deps[target_platform]:
            if dep in cb_stubs or dep in bd_ignored:
                continue
            else:
                if dep in blackduck_manifest['components']:
                    bd_dep_name = dep
                else:
                    blackduck['missing'][dep] = deps[target_platform][dep]
                    continue
                bd_vers = list(map(raw_version_string, blackduck_manifest['components'][bd_dep_name]['versions']))
                if deps[target_platform][dep] in bd_vers:
                    continue
                else:
                    blackduck['drifted'][dep] = { "version": deps[target_platform][dep],"bd-versions": bd_vers}

    # Figure out what packages have been removed from black duck manifest
    for bd_dep in blackduck_manifest['components']:
        found = False
        for target_platform in deps:
            for dep in deps[target_platform]:
                if dep == bd_dep:
                    found = True
        if not found:
            blackduck['removed'][bd_dep] = ""

    # If we've got missing/drifted/removed packages, just show the relevant
    # info and error out
    if any(problem in blackduck for problem in ['missing', 'drifted', 'removed']):
        print("ERROR: couchbase-server-black-duck-manifest.yaml is incorrect!")
        print("no environment files will be generated until the below items have been actioned")
        if blackduck['missing']:
            print()
            print("Missing deps:")
            for dep in blackduck['missing']:
                print(f"   {dep} ({blackduck['missing'][dep]})")
        if blackduck['drifted']:
            print()
            print("Drifted deps:")
            for dep in blackduck['drifted']:
                print("  ", dep, blackduck['drifted'][dep])
        if blackduck['removed']:
            print()
            print("Removed deps:")
            for dep in blackduck['removed']:
                print("  ", dep)
        sys.exit(1)

cb_stubs = get_version_dict("cb-stubs.txt")
cb_dependencies = get_version_dict("cb-dependencies.txt")
deps = get_deps()
update_cb_versions(cb_dependencies, cb_stubs, deps)
detect_blackduck_drift()
write_environment_files(deps)
